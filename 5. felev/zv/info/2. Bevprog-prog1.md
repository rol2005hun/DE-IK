<div align="center">
  <img src="https://img.shields.io/badge/Z√°r√≥vizsga-Programoz√°s%20alapok-blue?style=for-the-badge" alt="Z√°r√≥vizsga Programoz√°s alapok" />
</div>

---

<details>
<summary><b>üî¢ Adatt√≠pusok, V√°ltoz√≥</b></summary>

| Fogalom | Le√≠r√°s | P√©lda |
|---|---|---|
| **Adatt√≠pus** | Meghat√°rozza, milyen t√≠pus√∫ √©rt√©ket t√°rolhat egy v√°ltoz√≥, milyen m≈±veletek v√©gezhet≈ëk rajta, mennyi mem√≥ri√°t foglal | int, float, char, bool, string, double, long, short, unsigned |
| **V√°ltoz√≥** | Olyan n√©vvel ell√°tott mem√≥riahely, amelyben √©rt√©ket t√°rolunk, a program fut√°sa sor√°n v√°ltozhat | `int szam = 5;` |

**Alapvet≈ë adatt√≠pusok:**
- Eg√©sz sz√°m: `int`, `short`, `long`, `unsigned int`
- Val√≥s sz√°m: `float`, `double`, `long double`
- Logikai: `bool`
- Karakter: `char`, `unsigned char`
- Sz√∂veg: `string`, `char[]`

**√ñsszetett adatt√≠pusok:**
- T√∂mb (array): azonos t√≠pus√∫ elemek sorozata
- Strukt√∫ra (struct): k√ºl√∂nb√∂z≈ë t√≠pus√∫ elemek csoportja
- Oszt√°ly (class): adatok √©s m≈±veletek egy√ºtt
- Enum: felsorolt t√≠pus

**Felhaszn√°l√≥ √°ltal defini√°lt t√≠pusok:**
- struct, class, enum, typedef

---
**Mi√©rt fontos az adatt√≠pus?**
- Meghat√°rozza, hogy a v√°ltoz√≥ milyen √©rt√©keket vehet fel, milyen m≈±veletek v√©gezhet≈ëk rajta, mennyi mem√≥ri√°t foglal, hogyan viselkedik a programban.
- Seg√≠t elker√ºlni a hib√°kat, optimaliz√°lja a mem√≥riakezel√©st, n√∂veli a program biztons√°g√°t.

**T√≠pusoss√°g el≈ënyei:**
- Hib√°k korai felismer√©se (ford√≠t√°skor)
- Mem√≥riahat√©konys√°g
- K√≥d olvashat√≥s√°ga, karbantarthat√≥s√°ga

**T√≠puskonverzi√≥k:**
- Implicit: automatikus (pl. int ‚Üí float)
- Explicit: k√©nyszer√≠tett (pl. (float)szam)
- Vesz√©lyek: pontoss√°g elveszt√©se, t√∫lcsordul√°s, adatveszt√©s

**Mem√≥riakezel√©s:**
- Minden t√≠pus m√°s-m√°s m√©retet foglal (int: 4 byte, char: 1 byte, double: 8 byte)
- Stack vs. heap: lok√°lis vs. dinamikus v√°ltoz√≥k

**Tipikus hib√°k:**
- T√≠puskonverzi√≥ (pl. int ‚Üí float): elveszhet a pontoss√°g
- T√∫lcsordul√°s: int t√∫l nagy √©rt√©ket kap
- Nem inicializ√°lt v√°ltoz√≥: v√©letlenszer≈± √©rt√©k
- Rossz t√≠pusv√°laszt√°s: felesleges mem√≥riahaszn√°lat
- String vs. char[]: karakterl√°nc kezel√©si hib√°k

**Best practice:**
- Mindig inicializ√°ld a v√°ltoz√≥kat!
- V√°laszd a legsz≈±kebb, de elegend≈ë t√≠pust!
- Dokument√°ld, hogy mi√©rt azt a t√≠pust v√°lasztottad!
- Haszn√°lj konstansokat, ha az √©rt√©k nem v√°ltozik!

**Vizsgatipp:**
- Mindig √≠rd le, hogy egy v√°ltoz√≥ milyen t√≠pus√∫, √©s mi√©rt azt v√°lasztottad!
- Rajzolj mem√≥riakezel√©si diagramot, mutasd be a t√≠pusok m√©ret√©t!

**Mem√≥riakezel√©s √°bra:**
```mermaid
flowchart LR
	V1[int szam] -->|4 byte| Mem√≥ria
	V2[char betu] -->|1 byte| Mem√≥ria
	V3[double d] -->|8 byte| Mem√≥ria
	V4[string szoveg] -->|v√°ltoz√≥| Mem√≥ria
```

**Gyakorlati p√©lda:**
```cpp
int szam = 2147483647; // int maximum
szam = szam + 1; // t√∫lcsordul√°s, szam √©rt√©ke: -2147483648

float f = 3.14f;
double d = 2.718281828;
char c = 'A';
bool igaz = true;
string nev = "Anna";

// T√∂mb
int tomb[5] = {1,2,3,4,5};

// Strukt√∫ra
struct Pont { int x; int y; } p1;

// Enum
enum Nap { Hetfo, Kedd, Szerda };
Nap n = Hetfo;
```

</details>

---

<details>
<summary><b>‚ûï M≈±veletek, oper√°torok, operandusok</b></summary>

| Fogalom | Le√≠r√°s | P√©lda |
|---|---|---|
| **M≈±velet** | Adatokon v√©gzett elj√°r√°s | √∂sszead√°s, kivon√°s |
| **Oper√°tor** | A m≈±veletet jel√∂l≈ë szimb√≥lum | `+`, `-`, `*`, `/`, `%`, `==`, `!=` |
| **Operandus** | Az oper√°tor √°ltal √∂sszekapcsolt √©rt√©kek | `a + b` eset√©n: a, b |

**Oper√°torok csoportjai:**
- Aritmetikai: `+`, `-`, `*`, `/`, `%`
- Rel√°ci√≥s: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Logikai: `&&`, `||`, `!`
- Hozz√°rendel√©s: `=`, `+=`, `-=`

---
**R√©szletes magyar√°zat:**

Az oper√°torok a programoz√°s alapvet≈ë √©p√≠t≈ëk√∂vei. Az operandusok az √©rt√©kek, amelyeken a m≈±velet v√©grehajt√≥dik. Az oper√°torok precedenci√°ja (m≈±veleti sorrend) fontos, pl. szorz√°s el≈ëbb, mint √∂sszead√°s.

**Precedencia p√©lda:**
`a + b * c` ‚Üí el≈ësz√∂r `b * c`, majd hozz√°adjuk `a`-t.

**Tipikus hib√°k:**
- Oszt√°s eg√©sz t√≠pusokkal: `5 / 2 = 2` (nem 2.5!)
- Logikai oper√°torok: `&&` √©s `||` r√∂vidz√°ras ki√©rt√©kel√©s

**Vizsgatipp:**
√çrd le, hogy egy kifejez√©sben mi az oper√°torok sorrendje, √©s hogyan befoly√°solja az eredm√©nyt!

**Gyakorlati p√©lda:**
```cpp
int a = 5, b = 2;
float c = a / b; // c = 2.0, nem 2.5!
c = (float)a / b; // c = 2.5
```

</details>

---

<details>
<summary><b>üîÄ Vez√©rl√©si szerkezetek</b></summary>

| Szerkezet | Le√≠r√°s | P√©lda |
|---|---|---|
| **El√°gaz√°s** | Felt√©tel alapj√°n k√ºl√∂nb√∂z≈ë utas√≠t√°sok | `if`, `else`, `switch` |
| **Ciklus** | Ism√©tl≈ëd≈ë utas√≠t√°sok | `for`, `while`, `do-while` |
| **Ugr√°s** | Vez√©rl√©s √°tad√°sa m√°s helyre | `break`, `continue`, `return` |

```c
if (a > b) {
	printf("a nagyobb");
} else {
	printf("b nagyobb vagy egyenl≈ë");
}

for (int i = 0; i < 5; i++) {
	printf("%d ", i);
}
```

---
**R√©szletes magyar√°zat:**

Vez√©rl√©si szerkezetek hat√°rozz√°k meg a program fut√°s√°nak menet√©t. El√°gaz√°sokkal d√∂nt√©seket hozunk, ciklusokkal ism√©tl√ºnk, ugr√°sokkal megszak√≠tjuk vagy folytatjuk a fut√°st.

**Ciklusok fajt√°i:**
- El≈ëtesztel≈ë: `while` (felt√©tel a ciklus el≈ëtt)
- Ut√≥tesztel≈ë: `do-while` (felt√©tel a ciklus ut√°n)
- Sz√°ml√°l√≥: `for` (ism√©tl√©ssz√°m ismert)

**Tipikus hib√°k:**
- V√©gtelen ciklus: felt√©tel sosem lesz hamis
- El√°gaz√°sban elfelejtett `else`: v√°ratlan viselked√©s

**Vizsgatipp:**
√çrd le, hogy a vez√©rl√©si szerkezet hogyan befoly√°solja a program fut√°s√°t, √©s adj p√©ld√°t v√©gtelen ciklusra!

**Gyakorlati p√©lda:**
```cpp
int i = 0;
while (i < 5) {
    printf("%d ", i);
    i++;
}
```

</details>

---

<details>
<summary><b>üßÆ Kifejez√©sek, Utas√≠t√°sok</b></summary>

| Fogalom | Le√≠r√°s | P√©lda |
|---|---|---|
| **Kifejez√©s** | Olyan r√©sz, amelynek van √©rt√©ke | `a + b * 2` |
| **Utas√≠t√°s** | V√©grehajtand√≥ m≈±velet, parancs | `x = 5;` |

**Kifejez√©s p√©ld√°k:**
- `x + y`
- `x > 10 && y < 5`

**Utas√≠t√°s p√©ld√°k:**
- V√°ltoz√≥ √©rt√©kad√°s: `a = 10;`
- F√ºggv√©nyh√≠v√°s: `print(a);`

---
**R√©szletes magyar√°zat:**

Kifejez√©s: minden olyan programr√©sz, amelynek van √©rt√©ke. Utas√≠t√°s: v√©grehajtand√≥ parancs, amely lehet kifejez√©s is (pl. √©rt√©kad√°s).

**Kifejez√©sek fajt√°i:**
- Liter√°l: konkr√©t √©rt√©k (`5`, `'a'`)
- √ñsszetett: t√∂bb oper√°tor, t√∂bb operandus
- F√ºggv√©nyh√≠v√°s: visszat√©r√©si √©rt√©kkel

**Tipikus hib√°k:**
- Kifejez√©s helyett utas√≠t√°s haszn√°lata, vagy ford√≠tva
- Z√°r√≥jelez√©s hi√°nya: m√°s eredm√©ny

**Vizsgatipp:**
√çrd le, hogy egy utas√≠t√°s mikor tartalmaz kifejez√©st, √©s adj p√©ld√°t!

**Gyakorlati p√©lda:**
```cpp
int a = 5;
int b = 10;
int c = a + b * 2; // kifejez√©s
printf("%d", c); // utas√≠t√°s
```

</details>

---

<details>
<summary><b>üì¶ Programegys√©gek, Param√©terek</b></summary>

| Fogalom | Le√≠r√°s | P√©lda |
|---|---|---|
| **Programegys√©g** | √ñn√°ll√≥an kezelhet≈ë k√≥dr√©szlet (pl. f√ºggv√©ny, elj√°r√°s, modul) | `int osszeg(int a, int b)` |
| **Param√©terki√©rt√©kel√©s** | F√ºggv√©nyh√≠v√°skor a param√©terek √©rt√©k√©nek meghat√°roz√°sa | `osszeg(2, 3)` |
| **Param√©ter√°tad√°s** | √ârt√©k vagy hivatkoz√°s szerint | `void f(int x)` (√©rt√©k), `void f(int &x)` (hivatkoz√°s) |

**P√©lda C++-ban:**
```cpp
int osszeg(int a, int b) {
	return a + b;
}
```

---
**R√©szletes magyar√°zat:**

Programegys√©g: √∂n√°ll√≥an kezelhet≈ë, √∫jrahasznos√≠that√≥ k√≥dr√©szlet (f√ºggv√©ny, elj√°r√°s, oszt√°ly, modul). Seg√≠ti a struktur√°lt programoz√°st, cs√∂kkenti a hib√°k sz√°m√°t.

**Param√©ter√°tad√°s m√≥djai:**
- √ârt√©k szerint: m√°solatot kap a f√ºggv√©ny
- Referencia szerint: eredeti v√°ltoz√≥t m√≥dos√≠tja
- Pointer szerint: c√≠m alapj√°n

**Tipikus hib√°k:**
- √ârt√©k szerinti √°tad√°sn√°l a v√°ltoz√°s nem l√°tszik k√≠v√ºl
- Referencia/pointer √°tad√°sn√°l v√©letlen m√≥dos√≠t√°s

**Vizsgatipp:**
√çrd le, hogy a param√©ter√°tad√°s m√≥dja hogyan befoly√°solja a f√ºggv√©ny m≈±k√∂d√©s√©t!

**Gyakorlati p√©lda:**
```cpp
void novel(int &x) {
    x++;
}
int a = 5;
novel(a); // a = 6
```

</details>

---

<details>
<summary><b>üß± Blokk, Hat√°sk√∂r, L√°that√≥s√°g</b></summary>

| Fogalom | Le√≠r√°s | P√©lda |
|---|---|---|
| **Blokk** | Kapcsol√≥d√≥ utas√≠t√°sok csoportja `{ ... }` | `if (...) { ... }` |
| **Hat√°sk√∂r (scope)** | Ahol egy v√°ltoz√≥ el√©rhet≈ë | lok√°lis, glob√°lis |
| **L√°that√≥s√°g** | V√°ltoz√≥, f√ºggv√©ny el√©rhet≈ës√©ge | public, private |

**P√©lda:**
```cpp
int x = 5; // glob√°lis
void f() {
	int y = 10; // lok√°lis
}
```

---
**R√©szletes magyar√°zat:**

Blokk: egym√°shoz tartoz√≥ utas√≠t√°sok csoportja, amelyben a v√°ltoz√≥k hat√°sk√∂re (scope) korl√°tozott. A hat√°sk√∂r hat√°rozza meg, hogy egy v√°ltoz√≥ hol √©rhet≈ë el. L√°that√≥s√°g: objektum-orient√°lt programoz√°sban a tagok el√©rhet≈ës√©ge (public, private, protected).

**Hat√°sk√∂r fajt√°i:**
- Glob√°lis: program minden r√©sz√©n el√©rhet≈ë
- Lok√°lis: csak adott blokkban
- Statikus: csak adott f√°jlban

**Tipikus hib√°k:**
- √Årny√©kol√°s: lok√°lis v√°ltoz√≥ elrejti a glob√°list
- V√©letlen√ºl glob√°lis v√°ltoz√≥ haszn√°lata

**Vizsgatipp:**
√çrd le, hogy egy v√°ltoz√≥ hol √©l, √©s mi t√∂rt√©nik, ha azonos nev≈± v√°ltoz√≥k vannak k√ºl√∂nb√∂z≈ë blokkokban!

**Gyakorlati p√©lda:**
```cpp
int x = 10;
void f() {
	int x = 20; // √°rny√©kolja a glob√°lis x-et
	printf("%d", x); // 20
}
printf("%d", x); // 10
```

</details>

---

<details>
<summary><b>üß© Absztrakt adatt√≠pus (ADT)</b></summary>

| Fogalom | Le√≠r√°s | P√©lda |
|---|---|---|
| **Absztrakt adatt√≠pus** | Olyan adatt√≠pus, amelynek csak a m≈±veleteit √©s viselked√©s√©t defini√°ljuk, a megval√≥s√≠t√°st elrejtj√ºk | lista, verem, sor |

**P√©lda:**
```cpp
class Verem {
	public:
		void push(int x);
		int pop();
};
```

---
**R√©szletes magyar√°zat:**

Az absztrakt adatt√≠pus (ADT) egy olyan modell, amely csak a m≈±veleteket √©s azok viselked√©s√©t √≠rja le, a bels≈ë megval√≥s√≠t√°st elrejti. Ez lehet≈ëv√© teszi, hogy a programoz√≥ csak a haszn√°latra koncentr√°ljon, ne a r√©szletekre.

**P√©ld√°k ADT-re:**
- Verem (stack): LIFO (Last In First Out)
- Sor (queue): FIFO (First In First Out)
- Lista: elemek sorozata

**Tipikus hib√°k:**
- Nem megfelel≈ë m≈±velet haszn√°lata (pl. √ºres veremb≈ël pop)
- Megval√≥s√≠t√°si r√©szletek kisziv√°rognak

**Vizsgatipp:**
√çrd le, hogy az ADT mi√©rt fontos az absztrakci√≥ban, √©s adj p√©ld√°t saj√°t ADT-re!

**Gyakorlati p√©lda:**
```cpp
class Sor {
    public:
        void betesz(int x);
        int kivesz();
};
```

</details>

---

<details>
<summary><b>‚ö†Ô∏è Kiv√©telkezel√©s</b></summary>

| Fogalom | Le√≠r√°s | P√©lda |
|---|---|---|
| **Kiv√©tel** | Rendk√≠v√ºli esem√©ny, amely megszak√≠tja a norm√°l programfut√°st | oszt√°s null√°val |
| **Kiv√©telkezel√©s** | Hib√°k kezel√©se, program stabilit√°s√°nak n√∂vel√©se | try-catch szerkezet |

**P√©lda C++-ban:**
```cpp
try {
	int x = 5 / 0;
} catch (const std::exception& e) {
	std::cout << "Hiba: " << e.what();
}
```

---
**R√©szletes magyar√°zat:**

Kiv√©tel: olyan esem√©ny, amely megszak√≠tja a norm√°l programfut√°st (pl. oszt√°s null√°val, f√°jl nem tal√°lhat√≥). Kiv√©telkezel√©s: a hib√°k kezel√©se, hogy a program ne √°lljon le v√°ratlanul.

**Kiv√©telkezel√©s l√©p√©sei:**
1. Kiv√©tel dob√°sa (`throw`)
2. Kiv√©tel elkap√°sa (`catch`)
3. Hibakezel√©s, helyre√°ll√≠t√°s

**Tipikus hib√°k:**
- Nem kezelt kiv√©tel: program le√°ll
- T√∫l √°ltal√°nos catch: nem tudjuk, mi a hiba

**Vizsgatipp:**
√çrd le, hogy a kiv√©telkezel√©s hogyan n√∂veli a program stabilit√°s√°t, √©s adj p√©ld√°t saj√°t kiv√©telre!

**Gyakorlati p√©lda:**
```cpp
try {
    throw std::runtime_error("Saj√°t hiba");
} catch (const std::exception& e) {
    std::cout << "Kiv√©tel: " << e.what();
}
```

</details>

---

<div align="center">
	<img src="https://img.shields.io/badge/Kidolgoz√°s%20v√©ge-success?style=for-the-badge" alt="Kidolgoz√°s v√©ge" />
</div>