<div align="center">
	<img src="https://img.shields.io/badge/Z√°r√≥vizsga-Oper√°ci√≥s%20rendszerek-darkgreen?style=for-the-badge" alt="Z√°r√≥vizsga Oprendszerek" />
</div>

---

<details>
<summary><b>üñ•Ô∏è Oper√°ci√≥s rendszer: elm√©let, architekt√∫ra, vizsgaszint≈± kidolgoz√°s</b></summary>

<br>
<b>Mi az oper√°ci√≥s rendszer?</b>

Az oper√°ci√≥s rendszer (OS) a sz√°m√≠t√≥g√©p legfontosabb szoftvere, amely a hardver √©s a felhaszn√°l√≥i programok k√∂z√∂tt k√∂zvet√≠t.

**F≈ë feladatai:**
- Er≈ëforr√°sok (CPU, mem√≥ria, h√°tt√©rt√°r, perif√©ri√°k) kezel√©se
- Folyamatok vez√©rl√©se, √ºtemez√©se
- F√°jlok szervez√©se, f√°jlrendszer kezel√©se
- Biztons√°g, jogosults√°gok, titkos√≠t√°s
- Kommunik√°ci√≥ (h√°l√≥zat, IPC)
- Felhaszn√°l√≥i √©lm√©ny biztos√≠t√°sa (CLI, GUI, webes, mobil)
- Hibakezel√©s, rendszerstabilit√°s, napl√≥z√°s

**Fel√©p√≠t√©s √©s architekt√∫ra**
| Modul | Le√≠r√°s |
|-------|--------|
| <b>Kernel</b> | Az OS magja, k√∂zvetlen√ºl kezeli a hardvert, folyamatokat, mem√≥ri√°t, eszk√∂z√∂ket, rendszerh√≠v√°sokat, v√©delmet, priorit√°sokat, szinkroniz√°ci√≥t |
| <b>Felhaszn√°l√≥i fel√ºlet</b> | Parancssor (CLI), grafikus (GUI), webes, √©rint≈ëk√©perny≈ës, hangvez√©relt |
| <b>Rendszerszolg√°ltat√°sok</b> | Folyamatkezel√©s, mem√≥riakezel√©s, f√°jlkezel√©s, h√°l√≥zat, eszk√∂zkezel√©s, jogosults√°gkezel√©s, napl√≥z√°s, audit√°l√°s, hibakezel√©s |
| <b>Modulok</b> | Driver-ek, protokoll stack-ek, biztons√°gi modulok, virtualiz√°ci√≥s r√©teg |

**Kernel t√≠pusok:**
- Monolitikus (Linux, Unix): minden funkci√≥ egyetlen nagy kernelben
- Mikrokernel (Minix, QNX): csak alap funkci√≥k a kernelben, t√∂bbi modul k√ºl√∂n
- Hibrid (Windows NT, macOS): monolitikus √©s mikrokernel elemek keverve

**Felhaszn√°l√≥i fel√ºlet t√≠pusai:**
- CLI: parancssoros, scriptelhet≈ë, fejlett adminisztr√°ci√≥
- GUI: grafikus, felhaszn√°l√≥bar√°t, multitasking, drag&drop
- Webes, mobil, embedded UI

**Rendszerszolg√°ltat√°sok r√©szletesen:**
- Folyamatkezel√©s: folyamatok l√©trehoz√°sa, futtat√°sa, √ºtemez√©se, szinkroniz√°ci√≥
- Mem√≥riakezel√©s: allok√°ci√≥, lapoz√°s, virtu√°lis mem√≥ria, cache
- F√°jlkezel√©s: f√°jlok, k√∂nyvt√°rak, jogosults√°gok, attrib√∫tumok
- H√°l√≥zat: TCP/IP, socket, routing, t≈±zfal
- Eszk√∂zkezel√©s: driver-ek, plug&play, I/O
- Biztons√°g: jogosults√°gok, titkos√≠t√°s, audit√°l√°s
- Hibakezel√©s: napl√≥z√°s, vissza√°ll√≠t√°s, redundancia

**Oszt√°lyoz√°s:**
- Felhaszn√°l√≥k sz√°ma szerint: egyfelhaszn√°l√≥s, t√∂bbfelhaszn√°l√≥s, szerver, embedded
- Feladatok sz√°ma szerint: egyfeladatos, t√∂bbfeladatos (multitasking), p√°rhuzamos, szimult√°n
- Id≈ëoszt√°s szerint: val√≥s idej≈± (RTOS), k√∂tegelt (batch), interakt√≠v, id≈ëoszt√°sos (time-sharing)
- Architekt√∫ra szerint: monolitikus, mikrokernel, modul√°ris, hibrid
- P√©ld√°k: Windows, Linux, macOS, Unix, Android, iOS, FreeBSD, Solaris, z/OS

---
<b>√Åbra: Oper√°ci√≥s rendszer architekt√∫ra (Mermaid)</b>
```mermaid
flowchart TD
	Hardver --> Kernel
	Kernel --> Felhaszn√°l√≥i programok
	Kernel --> Rendszerszolg√°ltat√°sok
	Kernel --> Driver-ek
	Kernel --> Biztons√°gi modulok
	Kernel --> Hibakezel√©s
```

---
<b>Best practice (vizsg√°n √©s a gyakorlatban):</b>
- Mindig friss√≠tsd az OS-t, haszn√°lj stabil driver-eket
- Monitorozd a rendszer er≈ëforr√°sait, napl√≥zd a hib√°kat
- Haszn√°lj biztons√°gi be√°ll√≠t√°sokat, t≈±zfalat, jogosults√°gokat
- Teszteld a rendszer stabilit√°s√°t, backup-olj rendszeresen
- Ismerd a kernel szerep√©t √©s a f≈ë modulokat, tudj p√©ld√°kat mondani!

<b>Tipikus hib√°k:</b>
- Kernel panic: kritikus hiba miatt a rendszer le√°ll
- Deadlock: k√©t folyamat egym√°sra v√°r, sosem folytat√≥dik
- Race condition: versenyhelyzet, nem v√©dett er≈ëforr√°s
- Mem√≥riasziv√°rg√°s: nem felszabad√≠tott mem√≥ria
- Jogosults√°gi hiba: root jog n√©lk√ºl nem lehet rendszerf√°jlt m√≥dos√≠tani
- Driver inkompatibilit√°s: hib√°s vagy elavult driver miatt instabilit√°s

<b>Vizsgatippek:</b>
- Mindig eml√≠tsd a kernel szerep√©t, √©s hogy az OS hogyan kezeli az er≈ëforr√°sokat!
- Rajzolj architekt√∫ra diagramot, mutasd be a f≈ë modulokat!
- P√©ld√°kkal illusztr√°ld a tipikus hib√°kat √©s azok elker√ºl√©s√©t!
- Hasonl√≠tsd √∂ssze a kernel t√≠pusokat, mondj p√©ld√°kat!
- Ismerd a f≈ë OS-eket, tudj legal√°bb 3-at felsorolni!

<b>Gyakorlati p√©ld√°k:</b>
- Kernel panic: Linuxban, ha kritikus hiba l√©p fel, a rendszer le√°ll
- Deadlock: k√©t folyamat egym√°sra v√°r, sosem folytat√≥dik
- Jogosults√°gi hiba: root jog n√©lk√ºl nem lehet rendszerf√°jlt m√≥dos√≠tani
- Race condition: t√∂bb folyamat egyszerre √≠r egy f√°jlba, adatveszt√©s
- Mem√≥riasziv√°rg√°s: hossz√∫ fut√°s√∫ programokn√°l lassul√°s

---
<b>Extra kidolgoz√°s, vizsgaszint≈± elm√©let:</b>
- Az OS a sz√°m√≠t√≥g√©p m≈±k√∂d√©s√©nek alapja, minden program az OS-en kereszt√ºl kommunik√°l a hardverrel.
- Kernel: minden er≈ëforr√°skezel√©s, folyamatkezel√©s, mem√≥riakezel√©s, eszk√∂zkezel√©s, rendszerh√≠v√°s rajta kereszt√ºl t√∂rt√©nik.
- Kernel t√≠pusok: monolitikus (Linux), mikrokernel (Minix, QNX), hibrid (Windows NT).
- Felhaszn√°l√≥i fel√ºlet: CLI (parancssoros, scriptelhet≈ë, fejlett adminisztr√°ci√≥), GUI (grafikus, felhaszn√°l√≥bar√°t, multitasking, drag&drop), webes, mobil, embedded UI.
- Rendszerszolg√°ltat√°sok: folyamatkezel√©s, mem√≥riakezel√©s, f√°jlkezel√©s, h√°l√≥zat, eszk√∂zkezel√©s, jogosults√°gkezel√©s, napl√≥z√°s, audit√°l√°s, hibakezel√©s.

</details>

---

<details>
<summary><b>üìÅ F√°jlok √©s f√°jlrendszerek</b></summary>

**F√°jl:** Adatok elnevezett, tart√≥s t√°rol√°si egys√©ge. Minden f√°jlnak van neve, t√≠pusa, m√©rete, jogosults√°ga.

**F√°jlrendszer:** A f√°jlok szervez√©s√©nek, t√°rol√°s√°nak √©s el√©r√©s√©nek m√≥dja. Hierarchikus (pl. Unix, Windows), vagy s√≠k (r√©gi rendszerek).

**F≈ëbb f√°jlrendszerek:** FAT, NTFS, ext4, HFS+, APFS

**F√°jlm≈±veletek:** l√©trehoz√°s, olvas√°s, √≠r√°s, t√∂rl√©s, √°tnevez√©s, jogosults√°gok m√≥dos√≠t√°sa

**Vizsgatipp:**
√çrd le, hogy a f√°jlrendszer hogyan szervezi a f√°jlokat, √©s mi√©rt fontos a jogosults√°gkezel√©s!

**Gyakorlati p√©lda (Unix parancsok):**
```sh
ls -l # f√°jlok list√°z√°sa jogosults√°gokkal
chmod 644 file.txt # jogosults√°g m√≥dos√≠t√°sa
rm file.txt # t√∂rl√©s
```
</details>

---


<details>
<summary><b>üîó Speci√°lis f√°jlok Unix alatt</b></summary>

<b>Speci√°lis f√°jlok:</b>
- <b>Eszk√∂zf√°jlok:</b> hardvereszk√∂z√∂k el√©r√©se (pl. /dev/sda, /dev/tty). Blokkeszk√∂z√∂k (merevlemez, pendrive), karakteres eszk√∂z√∂k (billenty≈±zet, eg√©r).
- <b>Nevezetes cs≈ëvezet√©kek (FIFO):</b> tart√≥s kommunik√°ci√≥ k√©t folyamat k√∂z√∂tt, pl. mkfifo parancs.
- <b>Socket f√°jlok:</b> h√°l√≥zati kommunik√°ci√≥, IPC, pl. /tmp/mysocket.
- <b>Symbolic link:</b> hivatkoz√°s m√°s f√°jlra, nem m√°solat, pl. ln -s.

<b>R√©szletes magyar√°zat:</b>
Az oper√°ci√≥s rendszer minden hardvereszk√∂zt f√°jlk√©nt kezel, √≠gy egys√©gesen lehet hozz√°f√©rni. Ez a Unix filoz√≥fia: "Minden eszk√∂z f√°jl!". Eszk√∂zf√°jlok lehetnek blokkeszk√∂z√∂k (pl. merevlemez) vagy karakteres eszk√∂z√∂k (pl. billenty≈±zet). Nevezetes cs≈ëvezet√©kek (FIFO) tart√≥s kommunik√°ci√≥t biztos√≠tanak k√©t folyamat k√∂z√∂tt. Socket f√°jlok IPC-t (Inter-Process Communication) √©s h√°l√≥zati kommunik√°ci√≥t tesznek lehet≈ëv√©. Symbolic link egy hivatkoz√°s, amely nem m√°solja az eredeti f√°jlt, csak r√°mutat.

<b>Tipikus hib√°k:</b>
- Symbolic link t√∂rl√©se: csak a link t√∂rl≈ëdik, az eredeti nem
- Eszk√∂zf√°jlok jogosults√°gainak helytelen be√°ll√≠t√°sa: adatveszt√©s, biztons√°gi kock√°zat
- FIFO nem olvas√°sa: blokkol√≥d√≥ folyamat
- Socket f√°jl helytelen haszn√°lata: kommunik√°ci√≥s hiba

<b>Vizsgatippek:</b>
- Mindig eml√≠tsd, hogy a Unixban minden eszk√∂z f√°jlk√©nt √©rhet≈ë el!
- √çrd le, hogy a /dev/null, /dev/zero, /dev/random mire haszn√°lhat√≥!
- Mutass be p√©ld√°t symbolic linkre, FIFO-ra, socketre!

<b>Gyakorlati p√©ld√°k:</b>
```sh
ln -s eredeti.txt link.txt # szimbolikus link l√©trehoz√°sa
cat /dev/null # speci√°lis eszk√∂zf√°jl haszn√°lata
mkfifo mypipe # nevezetes cs≈ëvezet√©k l√©trehoz√°sa
echo "hello" > mypipe &
cat mypipe
```

<b>Advanced p√©lda:</b>
```sh
cat /dev/zero | head -c 10 # 10 null byte ki√≠r√°sa
cat /dev/random | head -c 8 # 8 random byte
```

</details>

---


<details>
<summary><b>‚û°Ô∏è √Åtir√°ny√≠t√°s, cs≈ëvezet√©kek (pipe)</b></summary>

<b>√Åtir√°ny√≠t√°s:</b>
- <b>Standard bemenet (stdin):</b> < ‚Äì parancs bemenet√©t f√°jlb√≥l olvassa
- <b>Standard kimenet (stdout):</b> > ‚Äì parancs kimenet√©t f√°jlba √≠rja
- <b>Standard hibakimenet (stderr):</b> 2> ‚Äì hib√°k kimenet√©t f√°jlba √≠rja

<b>Cs≈ëvezet√©k (pipe):</b> | ‚Äì k√©t folyamat kimenet√©t/bemenet√©t √∂sszekapcsolja, az egyik kimenete a m√°sik bemenete lesz

<b>R√©szletes magyar√°zat:</b>
Az √°tir√°ny√≠t√°s lehet≈ëv√© teszi, hogy a parancsok bemenet√©t vagy kimenet√©t f√°jlba, illetve m√°s parancsba ir√°ny√≠tsuk. Ez a Unix filoz√≥fia egyik alapja: "minden parancs egy dolgot csin√°l j√≥l". A pipe (|) seg√≠ts√©g√©vel t√∂bb parancsot l√°ncolhatunk √∂ssze, √≠gy komplex m≈±veleteket v√©gezhet√ºnk egyszer≈± parancsok kombin√°l√°s√°val. Az √°tir√°ny√≠t√°s √©s pipe lehet≈ëv√© teszi a parancsok kombin√°l√°s√°t, automatiz√°l√°s√°t, hibakezel√©s√©t.

<b>Tipikus hib√°k:</b>
- Hibakimenet √°tir√°ny√≠t√°sa elfelejtve: hiba√ºzenetek nem l√°tszanak, nehezebb hibakeres√©s
- Pipe-ban bufferel√©s: nagy adatmennyis√©g eset√©n lassul√°s, k√©sleltet√©s
- Hib√°s szintaxis: > helyett >>, vagy 2> helyett &>
- T√∂bb pipe egym√°s ut√°n: neh√©z k√∂vetni az adatfolyamot

<b>Vizsgatippek:</b>
- √çrd le, hogy az √°tir√°ny√≠t√°s √©s pipe hogyan seg√≠ti a parancsok kombin√°l√°s√°t!
- Mutass be p√©ld√°t hibakimenet √°tir√°ny√≠t√°s√°ra!
- Mutass be t√∂bb pipe-ot egym√°s ut√°n!
- Magyar√°zd el, mi√©rt hasznos a parancsok l√°ncol√°sa!

<b>Gyakorlati p√©ld√°k:</b>
```sh
cat file.txt | grep "alma" > eredmeny.txt
ls -l > lista.txt 2> hibak.txt
cat file.txt | grep "alma" | sort | uniq > eredmeny.txt
echo "hiba" 1> kimenet.txt 2> hibak.txt
```

<b>Advanced p√©lda:</b>
```sh
cat adat.txt | grep "error" | sort | uniq | tee errors.txt
```

</details>

---


<details>
<summary><b>‚öôÔ∏è Folyamatkezel√©s</b></summary>

<b>Folyamat (process):</b> Fut√≥ program, saj√°t mem√≥riater√ºlettel, azonos√≠t√≥val (PID), √°llapottal. Minden folyamatnak van sz√ºl≈ëje (parent), lehetnek gyerekfolyamatok (child).

<b>Folyamatkezel√©s:</b>
- L√©trehoz√°s (fork, exec)
- Futtat√°s, felf√ºggeszt√©s, le√°ll√≠t√°s
- Priorit√°s, √ºtemez√©s
- Kommunik√°ci√≥ (IPC: pipe, shared memory, message queue, signals)

<b>Folyamat√°llapotok:</b> fut, v√°rakozik, le√°llt, felf√ºggesztett, zombie, orphan

<b>R√©szletes magyar√°zat:</b>
A folyamatkezel√©s az OS egyik legfontosabb feladata. Minden folyamatnak van PID-je, saj√°t mem√≥riater√ºlete, jogosults√°ga. Folyamatok k√∂z√∂tti kommunik√°ci√≥: pipe, shared memory, message queue, signals. Folyamatok sz√ºl≈ë-gyerek viszonya: fork, exec. A fork() √∫j folyamatot hoz l√©tre, az exec() √∫j programot ind√≠t a folyamatban.

<b>Tipikus hib√°k:</b>
- Zombie folyamat: sz√ºl≈ë nem veszi √°t a kil√©p√©si st√°tuszt
- Orphan folyamat: sz√ºl≈ë megsz≈±nik, init veszi √°t
- V√©letlen kill: rossz PID
- Folyamatok t√∫lzott sz√°ma: er≈ëforr√°s-kimer√ºl√©s

<b>Vizsgatippek:</b>
- Mindig eml√≠tsd a PID szerep√©t, √©s hogy a folyamatok hogyan kommunik√°lnak!
- √çrd le, hogy a fork() √©s exec() hogyan m≈±k√∂dik, √©s mutass be sz√ºl≈ë-gyerek folyamatot!
- Mutass p√©ld√°t IPC-re (pipe, shared memory, signals)!

<b>Gyakorlati p√©ld√°k:</b>
```sh
ps aux # folyamatok list√°z√°sa
kill -9 1234 # folyamat le√°ll√≠t√°sa
top # folyamatok figyel√©se
```

<b>Advanced p√©lda (C):</b>
```c
pid_t pid = fork();
if (pid == 0) {
	// gyerek folyamat
	execlp("ls", "ls", NULL);
} else {
	// sz√ºl≈ë folyamat
	wait(NULL);
}
```

</details>

---


<details>
<summary><b>üì£ Jelz√©sek, szign√°lok (signals)</b></summary>

<b>Szign√°l:</b> Az OS vagy m√°s folyamat √°ltal k√ºld√∂tt esem√©ny, amely megszak√≠tja vagy m√≥dos√≠tja a folyamat m≈±k√∂d√©s√©t. Szign√°lokkal lehet folyamatokat vez√©relni, kommunik√°lni, hib√°t jelezni.

<b>F≈ëbb szign√°lok:</b>
- SIGINT: megszak√≠t√°s (Ctrl+C)
- SIGTERM: le√°ll√≠t√°s
- SIGKILL: azonnali le√°ll√≠t√°s (nem kezelhet≈ë)
- SIGSTOP: felf√ºggeszt√©s (nem kezelhet≈ë)
- SIGCONT: folytat√°s

<b>R√©szletes magyar√°zat:</b>
Szign√°lokkal az OS vagy m√°s folyamat esem√©nyt k√ºld egy folyamatnak. A folyamat kezelheti (signal handler), figyelmen k√≠v√ºl hagyhatja, vagy le√°llhat. N√©h√°ny szign√°l nem kezelhet≈ë (SIGKILL, SIGSTOP). Szign√°lokkal lehet folyamatokat vez√©relni, kommunik√°lni, hib√°t jelezni. Signal handler: saj√°t f√ºggv√©ny, amelyet a folyamat h√≠v meg szign√°l √©rkez√©sekor.

<b>Tipikus hib√°k:</b>
- SIGKILL haszn√°lata: nem fut le a takar√≠t√°s, er≈ëforr√°sok nem szabadulnak fel
- Signal handler helytelen implement√°ci√≥ja: nem megfelel≈ë hibakezel√©s
- Szign√°lok figyelmen k√≠v√ºl hagy√°sa: nem reag√°l a folyamat

<b>Vizsgatippek:</b>
- √çrd le, hogy a szign√°lok hogyan seg√≠tik a folyamatok vez√©rl√©s√©t!
- Mutass p√©ld√°t saj√°t szign√°lkezel≈ëre (signal handler)!
- Ismerd a f≈ëbb szign√°lokat, tudj p√©ld√°t mondani!

<b>Gyakorlati p√©ld√°k:</b>
```sh
kill -SIGSTOP 1234 # folyamat felf√ºggeszt√©se
kill -SIGCONT 1234 # folytat√°s
```

<b>Advanced p√©lda (C):</b>
```c
#include <signal.h>
void handler(int sig) {
	printf("Szign√°l √©rkezett: %d\n", sig);
}
signal(SIGINT, handler);
```

</details>

---


<details>
<summary><b>‚è∞ √útemezett v√©grehajt√°s (scheduling)</b></summary>

<b>√útemez√©s:</b> Az OS d√∂nti el, melyik folyamat mikor kap CPU-t. C√©l: hat√©konys√°g, v√°laszid≈ë, igazs√°goss√°g, priorit√°s. Preempt√≠v √ºtemez√©s: az OS megszak√≠thatja a folyamatot. Nem-preempt√≠v: a folyamat mag√°t√≥l adja √°t a CPU-t.

<b>√útemez√©si algoritmusok:</b>
- FIFO: els≈ëk√©nt √©rkezett kap el≈ësz√∂r CPU-t
- Round Robin: minden folyamat kap egy id≈ëkvantumot, k√∂rbe-k√∂rbe
- Priorit√°sos: magasabb priorit√°s√∫ folyamat el≈ëbb fut
- Val√≥s idej≈±: garant√°lt v√°laszid≈ë, pl. RTOS

<b>R√©szletes magyar√°zat:</b>
Az √ºtemez√©s (scheduling) az OS egyik legfontosabb feladata, mert meghat√°rozza a rendszer teljes√≠tm√©ny√©t, v√°laszidej√©t, igazs√°goss√°g√°t. A preempt√≠v √ºtemez√©s lehet≈ëv√© teszi, hogy az OS megszak√≠tsa a folyamatot, ha lej√°r az id≈ëkvantum vagy magasabb priorit√°s√∫ folyamat √©rkezik. Nem-preempt√≠v esetben a folyamat mag√°t√≥l adja √°t a CPU-t.

<b>Tipikus hib√°k:</b>
- Priorit√°s helytelen be√°ll√≠t√°sa: starvation (√©hez√©s, alacsony priorit√°s√∫ folyamat nem kap CPU-t)
- FIFO algoritmus: hossz√∫ fut√°s√∫ folyamatok blokkolj√°k a r√∂videket
- Id≈ëkvantum t√∫l r√∂vid/hossz√∫: t√∫l sok v√°lt√°s vagy lass√∫ v√°laszid≈ë

<b>Vizsgatippek:</b>
- Mindig eml√≠tsd, hogy az √ºtemez√©s hogyan befoly√°solja a rendszer teljes√≠tm√©ny√©t!
- √çrd le, hogy a Round Robin algoritmus hogyan m≈±k√∂dik, √©s mutass be id≈ëkvantumot!
- Hasonl√≠tsd √∂ssze a preempt√≠v √©s nem-preempt√≠v √ºtemez√©st!

<b>Gyakorlati p√©ld√°k:</b>
```sh
nice -n 10 program # alacsonyabb priorit√°ssal futtat√°s
at 12:00 program # √ºtemezett futtat√°s
crontab -e # id≈ëz√≠tett feladatok be√°ll√≠t√°sa
* * * * * echo "Hello" >> log.txt
```

</details>

---

<div align="center">
	<img src="https://img.shields.io/badge/Kidolgoz√°s%20v√©ge-success?style=for-the-badge" alt="Kidolgoz√°s v√©ge" />
</div>