<div align="center">
	<img src="https://img.shields.io/badge/Z√°r√≥vizsga-Oper√°ci√≥s%20rendszerek-darkgreen?style=for-the-badge" alt="Z√°r√≥vizsga Oprendszerek" />
</div>

---

<details>
<summary><b>üñ•Ô∏è Oper√°ci√≥s rendszerek fogalma, fel√©p√≠t√©se, oszt√°lyoz√°suk</b></summary>

# Oper√°ci√≥s rendszerek ‚Äì r√©szletes kidolgoz√°s

## 1. Fogalom, szerep, t√∂rt√©net
Az oper√°ci√≥s rendszer (OS) a sz√°m√≠t√≥g√©p legfontosabb szoftvere, amely a hardver √©s a felhaszn√°l√≥i programok k√∂z√∂tt k√∂zvet√≠t. F≈ë feladatai:
- Er≈ëforr√°sok kezel√©se: CPU, mem√≥ria, h√°tt√©rt√°r, perif√©ri√°k
- Programok futtat√°sa, vez√©rl√©se
- Biztons√°g, stabilit√°s, megb√≠zhat√≥s√°g
- Felhaszn√°l√≥i √©lm√©ny biztos√≠t√°sa
- Hardver absztrakci√≥, interf√©sz biztos√≠t√°sa

**T√∂rt√©neti √°ttekint√©s:**
- Els≈ë gener√°ci√≥: k√∂tegelt rendszerek, lyukk√°rtya, manu√°lis vez√©rl√©s
- M√°sodik gener√°ci√≥: multiprogramoz√°s, id≈ëoszt√°s
- Harmadik gener√°ci√≥: interakt√≠v rendszerek, GUI, multitasking
- Modern OS: virtualiz√°ci√≥, kont√©neriz√°ci√≥, felh≈ë, mobil, IoT

## 2. Architekt√∫ra, f≈ë modulok
Az OS architekt√∫r√°ja mag√°ban foglalja:
- Kernel (mag): k√∂zvetlen√ºl kezeli a hardvert, folyamatokat, mem√≥ri√°t, eszk√∂z√∂ket, rendszerh√≠v√°sokat, v√©delmet, priorit√°sokat, szinkroniz√°ci√≥t
- Felhaszn√°l√≥i fel√ºlet: CLI (parancssor), GUI (grafikus), webes, √©rint≈ëk√©perny≈ës, hangvez√©relt
- Rendszerszolg√°ltat√°sok: folyamatkezel√©s, mem√≥riakezel√©s, f√°jlkezel√©s, h√°l√≥zat, eszk√∂zkezel√©s, jogosults√°gkezel√©s, hibakezel√©s
- Modulok: driver-ek, protokoll stack-ek, biztons√°gi modulok, virtualiz√°ci√≥s r√©teg, plug-in architekt√∫ra

**√Åbra: Oper√°ci√≥s rendszer architekt√∫ra (Mermaid)**
```mermaid
flowchart TD
    Hardver --> Kernel
    Kernel --> FelhasznaloiProgramok
    Kernel --> Rendszerszolgaltatasok
    Kernel --> Driverek
    Kernel --> BiztonsagiModulok
    Kernel --> Hibakezeles
    Kernel --> Virtualizacio
    Kernel --> Fajlkezeles
    Kernel --> Memoriakezeles
    Kernel --> Halozat
```

## 3. Kernel t√≠pusok √©s architekt√∫r√°k
- Monolitikus kernel: minden funkci√≥ egyetlen nagy kernelben (Linux, Unix)
- Mikrokernel: csak alap funkci√≥k a kernelben, t√∂bbi modul k√ºl√∂n (Minix, QNX, L4)
- Hibrid kernel: monolitikus √©s mikrokernel elemek keverve (Windows NT, macOS, XNU)
- Modul√°ris kernel: dinamikusan bet√∂lthet≈ë modulok, driver-ek (modern Linux, Solaris)
- Virtualiz√°ci√≥s architekt√∫ra: Hypervisor, VM-ek, kont√©neriz√°ci√≥ (Docker, LXC)

**√Åbra: Kernel t√≠pusok √∂sszehasonl√≠t√°sa**
![Kernel architekt√∫r√°k](https://upload.wikimedia.org/wikipedia/commons/5/5f/Kernel_Comparison.svg)

## 4. Oszt√°lyoz√°s
- Felhaszn√°l√≥k sz√°ma szerint: egyfelhaszn√°l√≥s (MS-DOS), t√∂bbfelhaszn√°l√≥s (Linux, Unix, Windows Server), szerver OS, embedded (RTOS, Android Things)
- Feladatok sz√°ma szerint: egyfeladatos, t√∂bbfeladatos (multitasking), p√°rhuzamos, szimult√°n
- Id≈ëoszt√°s szerint: val√≥s idej≈± (RTOS), k√∂tegelt (batch), interakt√≠v, id≈ëoszt√°sos (Unix, Linux)
- Architekt√∫ra szerint: monolitikus, mikrokernel, modul√°ris, hibrid, virtualiz√°lt

## 5. Modern trendek
- Virtualiz√°ci√≥, kont√©neriz√°ci√≥, felh≈ë OS-ek (Kubernetes, OpenStack)
- Mobil OS-ek, IoT, edge computing
- Biztons√°g, patch management, zero trust

**P√©ld√°k:**
- Windows, Linux, macOS, Unix, Android, iOS, FreeBSD, Solaris, z/OS, Chrome OS, QNX, Minix, OpenBSD

## 6. Vizsgatippek, workflow
- Mindig eml√≠tsd a kernel szerep√©t, √©s hogy az OS hogyan kezeli az er≈ëforr√°sokat!
- Rajzolj architekt√∫ra diagramot, mutasd be a f≈ë modulokat!
- P√©ld√°kkal illusztr√°ld a tipikus hib√°kat √©s azok elker√ºl√©s√©t!
- Hasonl√≠tsd √∂ssze a kernel t√≠pusokat, mondj p√©ld√°kat!
- Ismerd a f≈ë OS-eket, tudj legal√°bb 3-at felsorolni!
- Workflow: probl√©ma felismer√©se (monitoring, logok), diagnosztika (dmesg, syslog, top, ps), hiba lokaliz√°l√°sa (strace, lsof, netstat), megold√°s (konfigur√°ci√≥, restart, patch), dokument√°l√°s, tanuls√°gok

</details>

<details>
<summary><b>üìÅ F√°jlok √©s f√°jlrendszerek</b></summary>

# F√°jlok √©s f√°jlrendszerek ‚Äì r√©szletes kidolgoz√°s

## 1. F√°jl fogalma, attrib√∫tumai
A f√°jl az adatok elnevezett, tart√≥s t√°rol√°si egys√©ge. Minden f√°jlnak van:
- Neve
- T√≠pusa (sz√∂veg, bin√°ris, program, k√©p, stb.)
- M√©rete
- Jogosults√°ga (olvas√°s, √≠r√°s, futtat√°s)
- L√©trehoz√°si, m√≥dos√≠t√°si d√°tuma

## 2. F√°jlrendszer fogalma, t√≠pusai
A f√°jlrendszer a f√°jlok szervez√©s√©nek, t√°rol√°s√°nak √©s el√©r√©s√©nek m√≥dja. Lehet:
- Hierarchikus (Unix, Windows): k√∂nyvt√°rak, almapp√°k
- S√≠k (r√©gi rendszerek): minden f√°jl egy szinten

**F≈ëbb f√°jlrendszerek:**
- FAT, NTFS (Windows)
- ext2, ext3, ext4 (Linux)
- HFS+, APFS (macOS)
- ZFS, XFS, Btrfs (halad√≥)

**√Åbra: F√°jlrendszer hierarchia**
```mermaid
graph TD
    root[Gy√∂k√©r]
    root --> home[home]
    root --> etc[etc]
    root --> var[var]
    home --> user1[user1]
    home --> user2[user2]
    user1 --> docs[docs]
    user1 --> pics[pics]
```

## 3. F√°jlm≈±veletek
- L√©trehoz√°s, olvas√°s, √≠r√°s, t√∂rl√©s, √°tnevez√©s
- Jogosults√°gok m√≥dos√≠t√°sa (chmod, chown)
- F√°jlok list√°z√°sa (ls, dir)
- F√°jlok keres√©se (find, locate)
- F√°jlok t√∂m√∂r√≠t√©se (zip, tar, gzip)

**P√©lda (Unix parancsok):**
```sh
ls -l # f√°jlok list√°z√°sa jogosults√°gokkal
chmod 644 file.txt # jogosults√°g m√≥dos√≠t√°sa
rm file.txt # t√∂rl√©s
```

## 4. Jogosults√°gkezel√©s
- Felhaszn√°l√≥k, csoportok
- Olvas√°s, √≠r√°s, futtat√°s jogok
- root/admin jogok
- ACL (Access Control List)

**√Åbra: Jogosults√°gok Unix f√°jlrendszerben**
![Jogosults√°gok](https://upload.wikimedia.org/wikipedia/commons/6/6a/Unix_file_permissions.png)

## 5. Tipikus hib√°k, hibaelh√°r√≠t√°s
- Hib√°s jogosults√°g: nem lehet olvasni/√≠rni
- F√°jl elveszt√©se, s√©r√ºl√©se
- F√°jlm≈±veletek helytelen haszn√°lata
- F√°jlok duplik√°ci√≥ja, szimbolikus linkek f√©lre√©rt√©se

## 6. Vizsgatippek
- √çrd le, hogy a f√°jlrendszer hogyan szervezi a f√°jlokat, √©s mi√©rt fontos a jogosults√°gkezel√©s!
- Mutass be p√©ld√°t f√°jlm≈±veletekre, jogosults√°gok m√≥dos√≠t√°s√°ra!

</details>

<details>
<summary><b>üîó Speci√°lis f√°jlok Unix alatt</b></summary>

# Speci√°lis f√°jlok Unix alatt ‚Äì r√©szletes kidolgoz√°s

## 1. Eszk√∂zf√°jlok
- Hardvereszk√∂z√∂k el√©r√©se: /dev/sda (merevlemez), /dev/tty (termin√°l)
- Blokkeszk√∂z√∂k: merevlemez, pendrive
- Karakteres eszk√∂z√∂k: billenty≈±zet, eg√©r

## 2. Nevezetes cs≈ëvezet√©kek (FIFO)
- Tart√≥s kommunik√°ci√≥ k√©t folyamat k√∂z√∂tt
- L√©trehoz√°s: mkfifo parancs
- Haszn√°lat: √≠r√°s, olvas√°s

## 3. Socket f√°jlok
- H√°l√≥zati kommunik√°ci√≥, IPC
- P√©lda: /tmp/mysocket
- Haszn√°lat: szerver-kliens kommunik√°ci√≥

## 4. Symbolic link
- Hivatkoz√°s m√°s f√°jlra, nem m√°solat
- L√©trehoz√°s: ln -s eredeti.txt link.txt
- T√∂rl√©s: csak a link t√∂rl≈ëdik, az eredeti nem

## 5. Speci√°lis eszk√∂zf√°jlok
- /dev/null: "fekete lyuk", minden bele√≠rt adat elveszik
- /dev/zero: null byte-ok gener√°l√°sa
- /dev/random: v√©letlen adatok gener√°l√°sa

**√Åbra: Unix eszk√∂zf√°jlok**
![Eszk√∂zf√°jlok](https://upload.wikimedia.org/wikipedia/commons/2/2b/Unix_device_files.png)

## 6. Tipikus hib√°k
- Symbolic link t√∂rl√©se: csak a link t√∂rl≈ëdik, az eredeti nem
- Eszk√∂zf√°jlok jogosults√°gainak helytelen be√°ll√≠t√°sa: adatveszt√©s, biztons√°gi kock√°zat
- FIFO nem olvas√°sa: blokkol√≥d√≥ folyamat
- Socket f√°jl helytelen haszn√°lata: kommunik√°ci√≥s hiba

## 7. Vizsgatippek
- Mindig eml√≠tsd, hogy a Unixban minden eszk√∂z f√°jlk√©nt √©rhet≈ë el!
- √çrd le, hogy a /dev/null, /dev/zero, /dev/random mire haszn√°lhat√≥!
- Mutass be p√©ld√°t symbolic linkre, FIFO-ra, socketre!

**Gyakorlati p√©ld√°k:**
```sh
ln -s eredeti.txt link.txt # szimbolikus link l√©trehoz√°sa
cat /dev/null # speci√°lis eszk√∂zf√°jl haszn√°lata
mkfifo mypipe # nevezetes cs≈ëvezet√©k l√©trehoz√°sa
cat /dev/zero | head -c 10 # 10 null byte ki√≠r√°sa
cat /dev/random | head -c 8 # 8 random byte
```

</details>

<details>
<summary><b>‚û°Ô∏è √Åtir√°ny√≠t√°s, cs≈ëvezet√©kek</b></summary>

# √Åtir√°ny√≠t√°s, cs≈ëvezet√©kek ‚Äì r√©szletes kidolgoz√°s

## 1. √Åtir√°ny√≠t√°s
- Standard bemenet (stdin): < ‚Äì parancs bemenet√©t f√°jlb√≥l olvassa
- Standard kimenet (stdout): > ‚Äì parancs kimenet√©t f√°jlba √≠rja
- Standard hibakimenet (stderr): 2> ‚Äì hib√°k kimenet√©t f√°jlba √≠rja
- T√∂bb √°tir√°ny√≠t√°s: 1> kimenet.txt 2> hibak.txt

## 2. Cs≈ëvezet√©k (pipe)
- | ‚Äì k√©t folyamat kimenet√©t/bemenet√©t √∂sszekapcsolja
- Az egyik kimenete a m√°sik bemenete lesz
- Parancsok l√°ncol√°sa, automatiz√°l√°s

**√Åbra: Pipe m≈±k√∂d√©se**
```mermaid
flowchart LR
    Parancs1 --|kimenet|--> Pipe --|bemenet|--> Parancs2
```

## 3. R√©szletes magyar√°zat
Az √°tir√°ny√≠t√°s √©s pipe lehet≈ëv√© teszi a parancsok kombin√°l√°s√°t, automatiz√°l√°s√°t, hibakezel√©s√©t. Ez a Unix filoz√≥fia egyik alapja: "minden parancs egy dolgot csin√°l j√≥l". Pipe-ban bufferel√©s: nagy adatmennyis√©g eset√©n lassul√°s, k√©sleltet√©s. Hib√°s szintaxis: > helyett >>, vagy 2> helyett &>. T√∂bb pipe egym√°s ut√°n: neh√©z k√∂vetni az adatfolyamot.

## 4. Tipikus hib√°k
- Hibakimenet √°tir√°ny√≠t√°sa elfelejtve: hiba√ºzenetek nem l√°tszanak, nehezebb hibakeres√©s
- Pipe-ban bufferel√©s: nagy adatmennyis√©g eset√©n lassul√°s, k√©sleltet√©s
- Hib√°s szintaxis: > helyett >>, vagy 2> helyett &>
- T√∂bb pipe egym√°s ut√°n: neh√©z k√∂vetni az adatfolyamot

## 5. Vizsgatippek
- √çrd le, hogy az √°tir√°ny√≠t√°s √©s pipe hogyan seg√≠ti a parancsok kombin√°l√°s√°t!
- Mutass be p√©ld√°t hibakimenet √°tir√°ny√≠t√°s√°ra!
- Mutass be t√∂bb pipe-ot egym√°s ut√°n!
- Magyar√°zd el, mi√©rt hasznos a parancsok l√°ncol√°sa!

**Gyakorlati p√©ld√°k:**
```sh
cat file.txt | grep "alma" > eredmeny.txt
ls -l > lista.txt 2> hibak.txt
cat file.txt | grep "alma" | sort | uniq > eredmeny.txt
echo "hiba" 1> kimenet.txt 2> hibak.txt
cat adat.txt | grep "error" | sort | uniq | tee errors.txt
```

</details>

<details>
<summary><b>‚öôÔ∏è Folyamatkezel√©s</b></summary>

# Folyamatkezel√©s ‚Äì r√©szletes kidolgoz√°s

## 1. Folyamat fogalma
A folyamat (process) fut√≥ program, saj√°t mem√≥riater√ºlettel, azonos√≠t√≥val (PID), √°llapottal. Minden folyamatnak van sz√ºl≈ëje (parent), lehetnek gyerekfolyamatok (child).

## 2. Folyamatkezel√©s
- L√©trehoz√°s (fork, exec)
- Futtat√°s, felf√ºggeszt√©s, le√°ll√≠t√°s
- Priorit√°s, √ºtemez√©s
- Kommunik√°ci√≥ (IPC: pipe, shared memory, message queue, signals)

**√Åbra: Folyamatok sz√ºl≈ë-gyerek viszonya**
```mermaid
graph TD
    SzuloFolyamat --> GyerekFolyamat1
    SzuloFolyamat --> GyerekFolyamat2
```

## 3. Folyamat√°llapotok
- fut, v√°rakozik, le√°llt, felf√ºggesztett, zombie, orphan

## 4. Tipikus hib√°k
- Zombie folyamat: sz√ºl≈ë nem veszi √°t a kil√©p√©si st√°tuszt
- Orphan folyamat: sz√ºl≈ë megsz≈±nik, init veszi √°t
- V√©letlen kill: rossz PID
- Folyamatok t√∫lzott sz√°ma: er≈ëforr√°s-kimer√ºl√©s

## 5. Vizsgatippek
- Mindig eml√≠tsd a PID szerep√©t, √©s hogy a folyamatok hogyan kommunik√°lnak!
- √çrd le, hogy a fork() √©s exec() hogyan m≈±k√∂dik, √©s mutass be sz√ºl≈ë-gyerek folyamatot!
- Mutass p√©ld√°t IPC-re (pipe, shared memory, signals)!

**Gyakorlati p√©ld√°k:**
```sh
ps aux # folyamatok list√°z√°sa
kill -9 1234 # folyamat le√°ll√≠t√°sa
top # folyamatok figyel√©se
```

**Advanced p√©lda (C):**
```c
pid_t pid = fork();
if (pid == 0) {
    // gyerek folyamat
    execlp("ls", "ls", NULL);
} else {
    // sz√ºl≈ë folyamat
    wait(NULL);
}
```

</details>

<details>
<summary><b>üì£ Jelz√©sek, szign√°lok</b></summary>

# Jelz√©sek, szign√°lok ‚Äì r√©szletes kidolgoz√°s

## 1. Szign√°l fogalma
A szign√°l az OS vagy m√°s folyamat √°ltal k√ºld√∂tt esem√©ny, amely megszak√≠tja vagy m√≥dos√≠tja a folyamat m≈±k√∂d√©s√©t. Szign√°lokkal lehet folyamatokat vez√©relni, kommunik√°lni, hib√°t jelezni.

## 2. F≈ëbb szign√°lok
- SIGINT: megszak√≠t√°s (Ctrl+C)
- SIGTERM: le√°ll√≠t√°s
- SIGKILL: azonnali le√°ll√≠t√°s (nem kezelhet≈ë)
- SIGSTOP: felf√ºggeszt√©s (nem kezelhet≈ë)
- SIGCONT: folytat√°s

**√Åbra: Szign√°lok hat√°sa folyamatokra**
```mermaid
graph TD
    Folyamat -- SIGINT --> Megszakitas
    Folyamat -- SIGTERM --> Leallitas
    Folyamat -- SIGKILL --> AzonnaliLeallitas
    Folyamat -- SIGSTOP --> Felfuggesztes
    Folyamat -- SIGCONT --> Folytatas
```

## 3. Signal handler
- Saj√°t f√ºggv√©ny, amelyet a folyamat h√≠v meg szign√°l √©rkez√©sekor
- P√©lda: C-ben signal(SIGINT, handler)

## 4. Tipikus hib√°k
- SIGKILL haszn√°lata: nem fut le a takar√≠t√°s, er≈ëforr√°sok nem szabadulnak fel
- Signal handler helytelen implement√°ci√≥ja: nem megfelel≈ë hibakezel√©s
- Szign√°lok figyelmen k√≠v√ºl hagy√°sa: nem reag√°l a folyamat

## 5. Vizsgatippek
- √çrd le, hogy a szign√°lok hogyan seg√≠tik a folyamatok vez√©rl√©s√©t!
- Mutass p√©ld√°t saj√°t szign√°lkezel≈ëre (signal handler)!
- Ismerd a f≈ëbb szign√°lokat, tudj p√©ld√°t mondani!

**Gyakorlati p√©ld√°k:**
```sh
kill -SIGSTOP 1234 # folyamat felf√ºggeszt√©se
kill -SIGCONT 1234 # folytat√°s
```

**Advanced p√©lda (C):**
```c
#include <signal.h>
void handler(int sig) {
    printf("Szign√°l √©rkezett: %d\n", sig);
}
signal(SIGINT, handler);
```

</details>

<details>
<summary><b>‚è∞ √útemezett v√©grehajt√°s</b></summary>

# √útemezett v√©grehajt√°s ‚Äì r√©szletes kidolgoz√°s

## 1. √útemez√©s fogalma
Az √ºtemez√©s (scheduling) az OS egyik legfontosabb feladata, mert meghat√°rozza a rendszer teljes√≠tm√©ny√©t, v√°laszidej√©t, igazs√°goss√°g√°t. Preempt√≠v √ºtemez√©s: az OS megszak√≠thatja a folyamatot. Nem-preempt√≠v: a folyamat mag√°t√≥l adja √°t a CPU-t.

## 2. √útemez√©si algoritmusok
- FIFO: els≈ëk√©nt √©rkezett kap el≈ësz√∂r CPU-t
- Round Robin: minden folyamat kap egy id≈ëkvantumot, k√∂rbe-k√∂rbe
- Priorit√°sos: magasabb priorit√°s√∫ folyamat el≈ëbb fut
- Val√≥s idej≈±: garant√°lt v√°laszid≈ë, pl. RTOS

**√Åbra: Round Robin √ºtemez√©s**
```mermaid
sequenceDiagram
    participant CPU
    participant F1 as Folyamat1
    participant F2 as Folyamat2
    participant F3 as Folyamat3
    CPU->>F1: id≈ëkvantum
    CPU->>F2: id≈ëkvantum
    CPU->>F3: id≈ëkvantum
    CPU->>F1: id≈ëkvantum
```

## 3. R√©szletes magyar√°zat
Az √ºtemez√©s meghat√°rozza, melyik folyamat mikor kap CPU-t. C√©l: hat√©konys√°g, v√°laszid≈ë, igazs√°goss√°g, priorit√°s. Preempt√≠v √ºtemez√©s lehet≈ëv√© teszi, hogy az OS megszak√≠tsa a folyamatot, ha lej√°r az id≈ëkvantum vagy magasabb priorit√°s√∫ folyamat √©rkezik. Nem-preempt√≠v esetben a folyamat mag√°t√≥l adja √°t a CPU-t.

## 4. Tipikus hib√°k
- Priorit√°s helytelen be√°ll√≠t√°sa: starvation (√©hez√©s, alacsony priorit√°s√∫ folyamat nem kap CPU-t)
- FIFO algoritmus: hossz√∫ fut√°s√∫ folyamatok blokkolj√°k a r√∂videket
- Id≈ëkvantum t√∫l r√∂vid/hossz√∫: t√∫l sok v√°lt√°s vagy lass√∫ v√°laszid≈ë

## 5. Vizsgatippek
- Mindig eml√≠tsd, hogy az √ºtemez√©s hogyan befoly√°solja a rendszer teljes√≠tm√©ny√©t!
- √çrd le, hogy a Round Robin algoritmus hogyan m≈±k√∂dik, √©s mutass be id≈ëkvantumot!
- Hasonl√≠tsd √∂ssze a preempt√≠v √©s nem-preempt√≠v √ºtemez√©st!

**Gyakorlati p√©ld√°k:**
```sh
nice -n 10 program # alacsonyabb priorit√°ssal futtat√°s
at 12:00 program # √ºtemezett futtat√°s
crontab -e # id≈ëz√≠tett feladatok be√°ll√≠t√°sa
* * * * * echo "Hello" >> log.txt
```

</details>

---

<div align="center">
	<img src="https://img.shields.io/badge/Kidolgoz√°s%20v√©ge-success?style=for-the-badge" alt="Kidolgoz√°s v√©ge" />
</div>