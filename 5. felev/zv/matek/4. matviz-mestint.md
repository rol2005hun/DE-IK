<div align="center">
	<img src="https://img.shields.io/badge/Z√°r√≥vizsga-Matviz%20√©s%20Mesters√©ges%20Intelligencia-blue?style=for-the-badge" alt="Z√°r√≥vizsga Matviz √©s Mesters√©ges Intelligencia" />
</div>

---

<details>
<summary><b>üìà F√ºggv√©nyek, g√∂rb√©k, fel√ºletek le√≠r√°sa √©s sz√°m√≠t√≥g√©pes √°br√°zol√°sa</b></summary>

| Fogalom | Le√≠r√°s |
|---|---|
| **F√ºggv√©ny** | Egy vagy t√∂bb v√°ltoz√≥hoz egy √©rt√©ket rendel (pl. $f(x)$, $f(x, y)$) |
| **G√∂rbe** | Egyv√°ltoz√≥s f√ºggv√©ny grafikonja a s√≠kban |
| **Fel√ºlet** | K√©tv√°ltoz√≥s f√ºggv√©ny grafikonja a t√©rben |
| **√Åbr√°zol√°s** | Grafikus megjelen√≠t√©s (plot, mesh, contour, stb.) |

**Sz√°m√≠t√≥g√©pes √°br√°zol√°s eszk√∂zei:**
- Python: matplotlib, numpy, plotly
- MATLAB: plot, surf, mesh

**K√≥dminta (Python, matplotlib):**
```python
import numpy as np
import matplotlib.pyplot as plt
x = np.linspace(-5, 5, 100)
y = x**2
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('y')
plt.title('y = x^2')
plt.show()
```

**Fel√ºlet √°br√°zol√°sa:**
```python
from mpl_toolkits.mplot3d import Axes3D
X, Y = np.meshgrid(x, x)
Z = X**2 + Y**2
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.plot_surface(X, Y, Z)
plt.show()
```

**Tipikus hib√°k:**
- Sk√°la, tengelyek elhagy√°sa
- Nem megfelel≈ë mintav√©telez√©s

**Best practice:**
- Mindig jel√∂ld a tengelyeket, adj c√≠met
- Haszn√°lj sz√≠nez√©st, kont√∫rt, ha seg√≠ti az √©rtelmez√©st

**Vizsgatipp:**
- Rajzolj k√©zzel is egyszer≈± g√∂rb√©t/fel√ºletet
- Magyar√°zd el, hogyan √°br√°zoln√°d sz√°m√≠t√≥g√©pen

</details>

---

<details>
<summary><b>üß© Probl√©m√°k reprezent√°l√°sa √°llapott√©ren</b></summary>

| Fogalom | Le√≠r√°s |
|---|---|
| **√Ållapott√©r** | Minden lehets√©ges √°llapot halmaza, amelyben a probl√©ma megold√°sa kereshet≈ë |
| **√Ållapot** | Egy konkr√©t konfigur√°ci√≥, pl. sakkt√°bla, kirak√≥, robot poz√≠ci√≥ja |
| **√Ållapot√°tmenet** | Egy l√©p√©s, amely egyik √°llapotb√≥l a m√°sikba visz |

**√Ållapott√©r reprezent√°ci√≥:**
- Gr√°f: cs√∫csok = √°llapotok, √©lek = l√©p√©sek
- Fa: gy√∂k√©r = kiindul√≥ √°llapot, levelek = v√©g√°llapotok

**Gyakorlati p√©lda:**
- 8 kir√°lyn≈ë probl√©ma: minden elhelyez√©s egy √°llapot
- Rubik-kocka: minden konfigur√°ci√≥ egy √°llapot

**Tipikus hib√°k:**
- √Ållapott√©r t√∫l nagy, nem kezelhet≈ë
- √Ållapotok nem egy√©rtelm≈±en defini√°ltak

**Best practice:**
- Minimaliz√°ld az √°llapott√©r m√©ret√©t
- Haszn√°lj egy√©rtelm≈± √°llapotle√≠r√°st

**Vizsgatipp:**
- Rajzolj √°llapott√©r-f√°t vagy gr√°fot
- Magyar√°zd el, hogyan k√≥doln√°d az √°llapotokat

</details>

---

<details>
<summary><b>üîÑ Megold√°s keres√©se visszal√©p√©ssel</b></summary>

| Fogalom | Le√≠r√°s |
|---|---|
| **Visszal√©p√©s (backtracking)** | Pr√≥b√°lkoz√≥ keres√©s, ha zs√°kutc√°ba jut, visszal√©p az el≈ëz≈ë √°llapotba |
| **Rekurzi√≥** | Algoritmus √∂nmag√°t h√≠vja, am√≠g megold√°st nem tal√°l vagy minden lehet≈ës√©get ki nem mer√≠t |

**Algoritmus l√©p√©sei:**
1. Kiindul√≥ √°llapotb√≥l indul
2. Pr√≥b√°l egy l√©p√©st
3. Ha nem j√≥, visszal√©p
4. Ha j√≥, tov√°bb pr√≥b√°l
5. Ha el√©rte a c√©lt, megold√°s

**K√≥dminta (8 kir√°lyn≈ë):**
```python
def solve(board, row):
    if row == 8:
        print(board)
        return True
    for col in range(8):
        if is_safe(board, row, col):
            board[row] = col
            if solve(board, row + 1):
                return True
            board[row] = -1
    return False
```

**Tipikus hib√°k:**
- V√©gtelen rekurzi√≥, ha nincs visszal√©p√©s
- Nem minden lehet≈ës√©get pr√≥b√°l ki

**Best practice:**
- Mindig ellen≈ërizd a visszal√©p√©s felt√©tel√©t
- Haszn√°lj √°llapotment√©st

**Vizsgatipp:**
- Rajzolj visszal√©p√©s-f√°t
- Magyar√°zd el, mikor √©rdemes visszal√©p√©st haszn√°lni

</details>

---

<details>
<summary><b>üå≥ Szisztematikus √©s heurisztikus fa- √©s gr√°fkeres≈ë elj√°r√°sok</b></summary>

| Elj√°r√°s | Le√≠r√°s | P√©lda |
|---|---|---|
| **Szisztematikus keres√©s** | Minden lehet≈ës√©get kipr√≥b√°l, garant√°lt megold√°s (pl. BFS, DFS, backtracking) | 8 kir√°lyn≈ë, labirintus |
| **Heurisztikus keres√©s** | Becsl√©st haszn√°l, gyorsabb, de nem garant√°lt a legjobb megold√°s (pl. A*, Greedy) | √∫tvonaltervez√©s, mesters√©ges intelligencia |

**Szisztematikus algoritmusok:**
- BFS: szintenk√©nt, sorral
- DFS: m√©lys√©gben, veremmel
- Backtracking: rekurzi√≥val, visszal√©p√©ssel

**Heurisztikus algoritmusok:**
- A*: $f(n) = g(n) + h(n)$, ahol $g(n)$ az eddigi k√∂lts√©g, $h(n)$ a becs√ºlt k√∂lts√©g a c√©lig
- Greedy: mindig a legjobb pillanatnyi l√©p√©st v√°lasztja

**K√≥dminta (A*):**
```python
import heapq
def astar(graph, start, goal, h):
    queue = [(h(start), 0, start, [])]
    visited = set()
    while queue:
        est, cost, node, path = heapq.heappop(queue)
        if node == goal:
            return path + [node]
        if node in visited:
            continue
        visited.add(node)
        for neighbor in graph[node]:
            heapq.heappush(queue, (cost + 1 + h(neighbor), cost + 1, neighbor, path + [node]))
    return None
```

**Tipikus hib√°k:**
- Heurisztika rossz v√°laszt√°sa: lass√∫ vagy hib√°s keres√©s
- Szisztematikus keres√©s t√∫l lass√∫ nagy √°llapott√©rben

**Best practice:**
- Haszn√°lj megfelel≈ë heurisztik√°t (pl. Manhattan-t√°vols√°g √∫tvonaltervez√©sn√©l)
- Kombin√°ld a keres√©si m√≥dszereket, ha lehet

**Vizsgatipp:**
- Rajzolj keres√©si f√°t, magyar√°zd el a l√©p√©seket
- Mutass p√©ld√°t mindk√©t keres√©sre

</details>

---

<div align="center">
	<img src="https://img.shields.io/badge/Kidolgoz√°s%20v√©ge-success?style=for-the-badge" alt="Kidolgoz√°s v√©ge" />
</div>